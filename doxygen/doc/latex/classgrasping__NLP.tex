\section{grasping\+\_\+\+N\+LP Class Reference}
\label{classgrasping__NLP}\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}


This class computes the grasping pose for a given hand and a superquadric modeling an objct by solving an optimization problem with the Ipopt software package.  




{\ttfamily \#include $<$superquadric.\+h$>$}



Inherits T\+N\+LP.

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classgrasping__NLP_abcf09fd329994523df9cebab0c607006}{init} (const yarp\+::sig\+::\+Vector \&objectext, yarp\+::sig\+::\+Vector \&handext, int \&n\+\_\+handpoints, const std\+::string \&str\+\_\+hand)
\begin{DoxyCompactList}\small\item\em Initialization function. \end{DoxyCompactList}\item 
void \hyperlink{classgrasping__NLP_ae0324a359506cd9d334b16cf8c4136ed}{check\+Zbound} ()\label{classgrasping__NLP_ae0324a359506cd9d334b16cf8c4136ed}

\begin{DoxyCompactList}\small\item\em Check if z axis has the maximum dimension for adjusting superquadric representation. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_afbe118dd339bb975cd5e340fa0801cec}{compute\+Points\+Hand} (yarp\+::sig\+::\+Vector \&\hyperlink{classgrasping__NLP_abdf5321a362b6b73b54271d81e8cdd17}{hand}, int j, int l, const std\+::string \&str\+\_\+hand, double \&theta)
\begin{DoxyCompactList}\small\item\em Samples points on the hand ellipsoid. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_a49d0b788d4d17f32efca951ed6556ca0}{get\+\_\+nlp\+\_\+info} (Ipopt\+::\+Index \&n, Ipopt\+::\+Index \&m, Ipopt\+::\+Index \&nnz\+\_\+jac\+\_\+g, Ipopt\+::\+Index \&nnz\+\_\+h\+\_\+lag, Ipopt\+::\+T\+N\+L\+P\+::\+Index\+Style\+Enum \&index\+\_\+style)
\begin{DoxyCompactList}\small\item\em Get info for the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_a1be828e10f1182f3befccbafdb90b577}{get\+\_\+bounds\+\_\+info} (Ipopt\+::\+Index n, Ipopt\+::\+Number $\ast$x\+\_\+l, Ipopt\+::\+Number $\ast$x\+\_\+u, Ipopt\+::\+Index m, Ipopt\+::\+Number $\ast$g\+\_\+l, Ipopt\+::\+Number $\ast$g\+\_\+u)
\begin{DoxyCompactList}\small\item\em Get variable bounds for the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_aad767e5f7e77a811e11817ff1d3d179e}{get\+\_\+starting\+\_\+point} (Ipopt\+::\+Index n, bool init\+\_\+x, Ipopt\+::\+Number $\ast$x, bool init\+\_\+z, Ipopt\+::\+Number $\ast$z\+\_\+L, Ipopt\+::\+Number $\ast$z\+\_\+U, Ipopt\+::\+Index m, bool init\+\_\+lambda, Ipopt\+::\+Number $\ast$lambda)
\begin{DoxyCompactList}\small\item\em Get the starting point for the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_aaceeaa1991c241e731f12434f3acb44c}{eval\+\_\+f} (Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Number \&obj\+\_\+value)
\begin{DoxyCompactList}\small\item\em Cost function of the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_a1ed524c1fd216594e82a6b066c59ff9c}{F} (const Ipopt\+::\+Number $\ast$x, std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&points\+\_\+on, bool new\+\_\+x)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing cost function of the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_a88efaceff4a2274a91e13dcc95ad46d1}{f} (yarp\+::sig\+::\+Vector \&obj, const Ipopt\+::\+Number $\ast$x, yarp\+::sig\+::\+Vector \&point)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing cost function of the nonlinear problem to be solved with ipopt. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_aa9ba169c71508e72c011cc43e94b1fed}{F\+\_\+v} (yarp\+::sig\+::\+Vector \&x, std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&points\+\_\+on)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing the gradient of cost function of the nonlinear problem. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_ab67b259991b21ef9c7d1a81a3cb31228}{f\+\_\+v} (yarp\+::sig\+::\+Vector \&obj, yarp\+::sig\+::\+Vector \&x, yarp\+::sig\+::\+Vector \&point)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing the gradient cost function of the nonlinear problem. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_a2cc9996f039f3049666a39bbf0e5a5f5}{f\+\_\+v2} (yarp\+::sig\+::\+Vector \&obj, yarp\+::sig\+::\+Vector \&x, yarp\+::sig\+::\+Vector \&point\+\_\+tr)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing the gradient cost function of the nonlinear problem. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_a91be45219cf7e32daa8934dd59295ba0}{eval\+\_\+grad\+\_\+f} (Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Number $\ast$grad\+\_\+f)
\begin{DoxyCompactList}\small\item\em Gradient of the cost function of the nonlinear problem. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_a5d2066df7d89a47af9d5b79940fe10ff}{eval\+\_\+g} (Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Index m, Ipopt\+::\+Number $\ast$g)
\begin{DoxyCompactList}\small\item\em Constraints of the nonlinear problem. \end{DoxyCompactList}\item 
double \hyperlink{classgrasping__NLP_acc0ace418469386b16adb2c70a98c14d}{G\+\_\+v} (yarp\+::sig\+::\+Vector \&x, int i)
\begin{DoxyCompactList}\small\item\em Auxiliary function for computing the constraints of the nonlinear problem. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_ab0e4e5721c5f018331ffe840022fb504}{eval\+\_\+jac\+\_\+g} (Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Index m, Ipopt\+::\+Index nele\+\_\+jac, Ipopt\+::\+Index $\ast$i\+Row, Ipopt\+::\+Index $\ast$j\+Col, Ipopt\+::\+Number $\ast$values)
\begin{DoxyCompactList}\small\item\em Jacobian of the constraints of the nonlinear problem. \end{DoxyCompactList}\item 
void \hyperlink{classgrasping__NLP_ab776f3ee1299d3927aa62b50f1bb3d3e}{configure} (yarp\+::os\+::\+Resource\+Finder $\ast$rf, const std\+::string \&left\+\_\+or\+\_\+right, const yarp\+::sig\+::\+Vector \&disp, const yarp\+::sig\+::\+Vector \&pl)
\begin{DoxyCompactList}\small\item\em Configure function. \end{DoxyCompactList}\item 
bool \hyperlink{classgrasping__NLP_a8104499f39d0f3705760a50745510c14}{read\+Matrix} (const std\+::string \&tag, yarp\+::sig\+::\+Matrix \&matrix, const int \&dimension, yarp\+::os\+::\+Resource\+Finder $\ast$rf)
\begin{DoxyCompactList}\small\item\em Function for reading matrices from config files. \end{DoxyCompactList}\item 
void \hyperlink{classgrasping__NLP_a99ab31792445766535d8117299b57da8}{finalize\+\_\+solution} (Ipopt\+::\+Solver\+Return status, Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, const Ipopt\+::\+Number $\ast$z\+\_\+L, const Ipopt\+::\+Number $\ast$z\+\_\+U, Ipopt\+::\+Index m, const Ipopt\+::\+Number $\ast$g, const Ipopt\+::\+Number $\ast$lambda, Ipopt\+::\+Number obj\+\_\+value, const Ipopt\+::\+Ipopt\+Data $\ast$ip\+\_\+data, Ipopt\+::\+Ipopt\+Calculated\+Quantities $\ast$ip\+\_\+cq)
\begin{DoxyCompactList}\small\item\em Finalize the solution. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_a15ce27b41ee64c471a66ea3f9db49381}{get\+\_\+result} () const 
\begin{DoxyCompactList}\small\item\em Extract the solution. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_a1c012d56ae1dc44263eac74861b59008}{get\+\_\+hand} () const 
\begin{DoxyCompactList}\small\item\em Get the hand ellipsoid pose. \end{DoxyCompactList}\item 
double {\bfseries get\+\_\+final\+\_\+F} () const \label{classgrasping__NLP_ad6facc271a6368426df5ffa995abe8f5}

\end{DoxyCompactItemize}
\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_abdf5321a362b6b73b54271d81e8cdd17}{hand}\label{classgrasping__NLP_abdf5321a362b6b73b54271d81e8cdd17}

\begin{DoxyCompactList}\small\item\em Hand ellipsoid. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_aa9ee2758debcf6e9d06cf904394fb2df}{object}\label{classgrasping__NLP_aa9ee2758debcf6e9d06cf904394fb2df}

\begin{DoxyCompactList}\small\item\em Object superquadric. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Matrix \hyperlink{classgrasping__NLP_a64e8645d3e469a6d3d532fdccd082fcc}{plane}\label{classgrasping__NLP_a64e8645d3e469a6d3d532fdccd082fcc}

\begin{DoxyCompactList}\small\item\em Plane representing the table. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_a331e541566751ac8cb85016d6878cc73}{solution}\label{classgrasping__NLP_a331e541566751ac8cb85016d6878cc73}

\begin{DoxyCompactList}\small\item\em Vector with the pose computed with the hand ellipsoid. \end{DoxyCompactList}\item 
yarp\+::sig\+::\+Vector \hyperlink{classgrasping__NLP_afe0fc80111d346ef60e17fc4c52439c9}{robot\+\_\+pose}\label{classgrasping__NLP_afe0fc80111d346ef60e17fc4c52439c9}

\begin{DoxyCompactList}\small\item\em Final robot pose. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classgrasping__NLP_a7528c5c50e79a6992d7a8af1221d0e7d}{l\+\_\+o\+\_\+r}\label{classgrasping__NLP_a7528c5c50e79a6992d7a8af1221d0e7d}

\begin{DoxyCompactList}\small\item\em Variable for setting hand of interest. \end{DoxyCompactList}\item 
double {\bfseries tmp\+\_\+value}\label{classgrasping__NLP_a7fe4c2cc412a8084f5a8aefd7b9bbc87}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class computes the grasping pose for a given hand and a superquadric modeling an objct by solving an optimization problem with the Ipopt software package. 

Definition at line 37 of file superquadric.\+h.



\subsection{Member Function Documentation}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!compute\+Points\+Hand@{compute\+Points\+Hand}}
\index{compute\+Points\+Hand@{compute\+Points\+Hand}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{compute\+Points\+Hand(yarp\+::sig\+::\+Vector \&hand, int j, int l, const std\+::string \&str\+\_\+hand, double \&theta)}{computePointsHand(yarp::sig::Vector &hand, int j, int l, const std::string &str_hand, double &theta)}}]{\setlength{\rightskip}{0pt plus 5cm}Vector grasping\+\_\+\+N\+L\+P\+::compute\+Points\+Hand (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{hand, }
\item[{int}]{j, }
\item[{int}]{l, }
\item[{const std\+::string \&}]{str\+\_\+hand, }
\item[{double \&}]{theta}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_afbe118dd339bb975cd5e340fa0801cec}


Samples points on the hand ellipsoid. 


\begin{DoxyParams}{Parameters}
{\em hand} & is the hand ellipsoid \\
\hline
{\em j} & is an index \\
\hline
{\em i} & is an index \\
\hline
{\em str\+\_\+hand} & is the name of the hand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a vector with the points sampled on the hand ellipsoid 
\end{DoxyReturn}


Definition at line 120 of file superquadric.\+cpp.


\begin{DoxyCode}
121 \{
122     Vector point(3,0.0);
123     \textcolor{keywordtype}{double} omega;
124     \textcolor{keywordtype}{double} ce,se,co,so;
125 
126     \textcolor{keywordflow}{if} (findMax(\textcolor{keywordtype}{object}.subVector(0,2))> findMax(hand.subVector(0,2)))
127         hand[1]=findMax(\textcolor{keywordtype}{object}.subVector(0,2));
128     \textcolor{comment}{//else if (findMax(object.subVector(0,2))<findMax(hand.subVector(0,2)))}
129     \textcolor{comment}{//    hand[1]=findMax(object.subVector(0,2));  }
130 
131 
132     \textcolor{keywordflow}{if} (str\_hand==\textcolor{stringliteral}{"right"})
133     \{
134         omega=j*2*M\_PI/(l);
135 
136         ce=cos(theta);
137         se=sin(theta);
138         co=cos(omega);
139         so=sin(omega);
140 
141         point[0]=hand[0] * sign(ce)*(pow(abs(ce),hand[3])) * sign(co)*(pow(abs(co),
      hand[4]));
142         point[1]=hand[1] * sign(ce)*(pow(abs(ce),hand[3])) * sign(so)*(pow(abs(so),
      hand[4]));
143         point[2]=hand[2] * sign(se)*(pow(abs(se),hand[3]));
144     \}
145     \textcolor{keywordflow}{else}
146     \{
147         omega=j*2*M\_PI/(l);
148 
149         ce=cos(theta+M\_PI/2);
150         se=sin(theta+M\_PI/2);
151         co=cos(omega);
152         so=sin(omega);
153 
154         point[0]=hand[0] * sign(ce)*(pow(abs(ce),hand[3])) * sign(co)*(pow(abs(co),
      hand[4]));
155         point[1]=hand[1] * sign(ce)*(pow(abs(ce),hand[3])) * sign(so)*(pow(abs(so),
      hand[4]));
156         point[2]=hand[2] * sign(se)*(pow(abs(se),hand[3]));
157     \}
158 
159     Vector point\_tr(4,0.0);
160 
161     euler[0]=hand[8];
162     euler[1]=hand[9];
163     euler[2]=hand[10];
164     H\_h2w=euler2dcm(euler);
165     euler[0]=hand[5];
166     euler[1]=hand[6];
167     euler[2]=hand[7];
168     H\_h2w.setSubcol(euler,0,3);
169 
170     Vector point\_tmp(4,1.0);
171     point\_tmp.setSubvector(0,point);
172     point\_tr=H\_h2w*point\_tmp;
173     point=point\_tr.subVector(0,2);
174 
175     \textcolor{keywordflow}{return} point;
176 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!configure@{configure}}
\index{configure@{configure}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{configure(yarp\+::os\+::\+Resource\+Finder $\ast$rf, const std\+::string \&left\+\_\+or\+\_\+right, const yarp\+::sig\+::\+Vector \&disp, const yarp\+::sig\+::\+Vector \&pl)}{configure(yarp::os::ResourceFinder *rf, const std::string &left_or_right, const yarp::sig::Vector &disp, const yarp::sig::Vector &pl)}}]{\setlength{\rightskip}{0pt plus 5cm}void grasping\+\_\+\+N\+L\+P\+::configure (
\begin{DoxyParamCaption}
\item[{yarp\+::os\+::\+Resource\+Finder $\ast$}]{rf, }
\item[{const std\+::string \&}]{left\+\_\+or\+\_\+right, }
\item[{const yarp\+::sig\+::\+Vector \&}]{disp, }
\item[{const yarp\+::sig\+::\+Vector \&}]{pl}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_ab776f3ee1299d3927aa62b50f1bb3d3e}


Configure function. 


\begin{DoxyParams}{Parameters}
{\em rf} & is the resource finder \\
\hline
{\em left\+\_\+or\+\_\+right} & can be right, left or both \\
\hline
{\em disp} & is the hand ellispoid displacement \\
\hline
{\em pl} & is the plane representing the table \\
\hline
\end{DoxyParams}


Definition at line 556 of file superquadric.\+cpp.


\begin{DoxyCode}
557 \{
558     Matrix x0\_tmp;
559     x0\_tmp.resize(6,1);
560     x0.resize(6,0.0);
561     readMatrix(\textcolor{stringliteral}{"x0"}+left\_or\_right,x0\_tmp,1,rf);
562     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i< 6; i++)
563         x0[i]=x0\_tmp(i,0);
564 
565     bounds.resize(6,2);
566     readMatrix(\textcolor{stringliteral}{"bounds\_"}+left\_or\_right,bounds, 6, rf);
567     bounds\_constr.resize(6,2);
568     readMatrix(\textcolor{stringliteral}{"bounds\_constr\_"}+left\_or\_right,bounds\_constr,6 , rf);
569     plane.resize(4,1);
570 
571     l_o_r=left\_or\_right;
572     displacement=disp;
573     plane.setCol(0,pl);
574 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!eval\+\_\+f@{eval\+\_\+f}}
\index{eval\+\_\+f@{eval\+\_\+f}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{eval\+\_\+f(\+Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Number \&obj\+\_\+value)}{eval_f(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number &obj_value)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::eval\+\_\+f (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{bool}]{new\+\_\+x, }
\item[{Ipopt\+::\+Number \&}]{obj\+\_\+value}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_aaceeaa1991c241e731f12434f3acb44c}


Cost function of the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em x} & is the variable \\
\hline
{\em new\+\_\+x} & takes into account is the variable has been updated or not \\
\hline
{\em obj\+\_\+value} & is the value of the cost function  true \\
\hline
\end{DoxyParams}


Definition at line 227 of file superquadric.\+cpp.


\begin{DoxyCode}
229  \{
230      F(x,points\_on,new\_x);
231      obj\_value=aux\_objvalue;
232 
233      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
234  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!eval\+\_\+g@{eval\+\_\+g}}
\index{eval\+\_\+g@{eval\+\_\+g}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{eval\+\_\+g(\+Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Index m, Ipopt\+::\+Number $\ast$g)}{eval_g(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Number *g)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::eval\+\_\+g (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{bool}]{new\+\_\+x, }
\item[{Ipopt\+::\+Index}]{m, }
\item[{Ipopt\+::\+Number $\ast$}]{g}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a5d2066df7d89a47af9d5b79940fe10ff}


Constraints of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em x} & is the variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em new\+\_\+x} & takes into account is the variable has been updated or not \\
\hline
{\em g} & is the values of the constraints \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 
\end{DoxyReturn}


Definition at line 387 of file superquadric.\+cpp.


\begin{DoxyCode}
389  \{
390      euler[0]=x[3];
391      euler[1]=x[4];
392      euler[2]=x[5];
393      H\_x=euler2dcm(euler);
394      euler[0]=x[0];
395      euler[1]=x[1];
396      euler[2]=x[2];
397      H\_x.setSubcol(euler,0,3);
398 
399      Matrix H(4,4);
400      H=H\_x*H\_h2w;
401 
402      g[0]=H(2,2);
403      g[1]=H(0,0);
404      g[2]=H(1,2);
405      g[4]=H(1,0);
406 
407      Vector x\_min;
408      \textcolor{keywordtype}{double} minz=10.0;
409 
410      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<points\_on.size(); i++)
411      \{
412          Vector pnt(4,1.0);
413          pnt.setSubvector(0,points\_on[i]);
414          Vector point=H\_x*pnt;
415 
416          \textcolor{keywordflow}{if} (point[2]<minz)
417          \{
418              minz=point[2];
419              x\_min=point;
420          \}
421      \}
422 
423      g[3]=plane(0,0)*x\_min[0]+plane(1,0)*x\_min[1]+plane(2,0)*x\_min[2]+plane(3,0);
424 
425      Vector robotPose(3,0.0);
426      Vector x\_tmp(6,0.0);
427      x\_tmp[0]=x[0];
428      x\_tmp[1]=x[1];
429      x\_tmp[2]=x[2];
430      x\_tmp[3]=x[3];
431      x\_tmp[4]=x[4];
432      x\_tmp[5]=x[5];
433 
434      \textcolor{keywordflow}{if} (l_o_r==\textcolor{stringliteral}{"right"})
435         robotPose=x\_tmp.subVector(0,2)-hand[0]*(H.getCol(2).subVector(0,2));
436      \textcolor{keywordflow}{else}
437          robotPose=x\_tmp.subVector(0,2)+hand[0]*(H.getCol(2).subVector(0,2));
438 
439      g[5]=\textcolor{keywordtype}{object}[0]*\textcolor{keywordtype}{object}[1]*\textcolor{keywordtype}{object}[2]*(pow(f_v2(\textcolor{keywordtype}{object},x\_tmp, robotPose), \textcolor{keywordtype}{object}[3]) -1);
440 
441      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
442  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!eval\+\_\+grad\+\_\+f@{eval\+\_\+grad\+\_\+f}}
\index{eval\+\_\+grad\+\_\+f@{eval\+\_\+grad\+\_\+f}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{eval\+\_\+grad\+\_\+f(\+Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Number $\ast$grad\+\_\+f)}{eval_grad_f(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Number *grad_f)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::eval\+\_\+grad\+\_\+f (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{bool}]{new\+\_\+x, }
\item[{Ipopt\+::\+Number $\ast$}]{grad\+\_\+f}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a91be45219cf7e32daa8934dd59295ba0}


Gradient of the cost function of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em x} & is the variable \\
\hline
{\em n} & is the dimension of the variable \\
\hline
{\em new\+\_\+x} & takes into account is the variable has been updated or not \\
\hline
{\em grad\+\_\+f} & is the gradient of the cost function \\
\hline
\end{DoxyParams}


Definition at line 360 of file superquadric.\+cpp.


\begin{DoxyCode}
362  \{
363      Vector x\_tmp(6,0.0);
364      \textcolor{keywordtype}{double} grad\_p, grad\_n;
365      \textcolor{keywordtype}{double} eps=1e-6;
366 
367      \textcolor{keywordflow}{for}(Ipopt::Index i=0;i<n;i++)
368         x\_tmp[i]=x[i];
369 
370      \textcolor{keywordflow}{for}(Ipopt::Index j=0;j<n;j++)
371      \{
372          x\_tmp[j]=x\_tmp[j]+eps;
373 
374          grad\_p=F_v(x\_tmp,points\_on);
375 
376          x\_tmp[j]=x\_tmp[j]-eps;
377 
378          grad\_n=F_v(x\_tmp,points\_on);
379 
380          grad\_f[j]=(grad\_p-grad\_n)/eps;
381      \}
382 
383      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
384  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!eval\+\_\+jac\+\_\+g@{eval\+\_\+jac\+\_\+g}}
\index{eval\+\_\+jac\+\_\+g@{eval\+\_\+jac\+\_\+g}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{eval\+\_\+jac\+\_\+g(\+Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, bool new\+\_\+x, Ipopt\+::\+Index m, Ipopt\+::\+Index nele\+\_\+jac, Ipopt\+::\+Index $\ast$i\+Row, Ipopt\+::\+Index $\ast$j\+Col, Ipopt\+::\+Number $\ast$values)}{eval_jac_g(Ipopt::Index n, const Ipopt::Number *x, bool new_x, Ipopt::Index m, Ipopt::Index nele_jac, Ipopt::Index *iRow, Ipopt::Index *jCol, Ipopt::Number *values)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::eval\+\_\+jac\+\_\+g (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{bool}]{new\+\_\+x, }
\item[{Ipopt\+::\+Index}]{m, }
\item[{Ipopt\+::\+Index}]{nele\+\_\+jac, }
\item[{Ipopt\+::\+Index $\ast$}]{i\+Row, }
\item[{Ipopt\+::\+Index $\ast$}]{j\+Col, }
\item[{Ipopt\+::\+Number $\ast$}]{values}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_ab0e4e5721c5f018331ffe840022fb504}


Jacobian of the constraints of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em x} & is the variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em new\+\_\+x} & takes into account is the variable has been updated or not \\
\hline
{\em i\+Row} & contains the jacobian raws \\
\hline
{\em i\+Col} & contains the jacobian columns \\
\hline
{\em values} & contains the jacobian values \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 
\end{DoxyReturn}


Definition at line 503 of file superquadric.\+cpp.


\begin{DoxyCode}
506  \{
507      Vector x\_tmp(6,0.0);
508      \textcolor{keywordtype}{double} grad\_p, grad\_n;
509      \textcolor{keywordtype}{double} eps=1e-6;
510 
511      \textcolor{keywordflow}{if}(values!=NULL)
512      \{
513          \textcolor{keywordflow}{for}(Ipopt::Index i=0;i<n;i++)
514             x\_tmp[i]=x[i];
515 
516          \textcolor{keywordtype}{int} count=0;
517          \textcolor{keywordflow}{for}(Ipopt::Index i=0;i<m; i++)
518          \{
519              \textcolor{keywordflow}{for}(Ipopt::Index j=0;j<n;j++)
520              \{
521                  x\_tmp[j]=x\_tmp[j]+eps;
522 
523                  grad\_p=G_v(x\_tmp,i);
524                  x\_tmp[j]=x\_tmp[j]-eps;
525 
526                  grad\_n=G_v(x\_tmp,i);
527 
528                  values[count]=(grad\_p-grad\_n)/(eps);
529                  count++;
530              \}
531          \}
532      \}
533      \textcolor{keywordflow}{else}
534     \{
535         jCol[0]=0; jCol[1]=1; jCol[2]=2; jCol[3]=3; jCol[4]=4; jCol[5]=5;
536         jCol[6]=0; jCol[7]=1; jCol[8]=2; jCol[9]=3; jCol[10]=4; jCol[11]=5;
537         jCol[12]=0; jCol[13]=1; jCol[14]=2;jCol[15]=3; jCol[16]=4; jCol[17]=5;
538         jCol[18]=0; jCol[19]=1; jCol[20]=2; jCol[21]=3; jCol[22]=4; jCol[23]=5;
539         jCol[24]=0; jCol[25]=1; jCol[26]=2; jCol[27]=3;jCol[28]=4;jCol[29]=5;
540         jCol[30]=0; jCol[31]=1; jCol[32]=2; jCol[33]=3;jCol[34]=4;jCol[35]=5;
541 
542         iRow[0]=iRow[1]=iRow[2]=iRow[3]=iRow[4]=iRow[5]=0;
543         iRow[6]=iRow[7]=iRow[8]=iRow[9]=iRow[10]=iRow[11]=1;
544         iRow[12]=iRow[13]=iRow[14]=iRow[15]=iRow[16]=iRow[17]=2;
545 
546         iRow[18]=iRow[19]=iRow[20]=iRow[21]=iRow[22]=iRow[23]=3;
547         iRow[24]=iRow[25]=iRow[26]=iRow[27]=iRow[28]=iRow[29]=4;
548         iRow[30]=iRow[31]=iRow[32]=iRow[33]=iRow[34]=iRow[35]=5;
549      \}
550 
551  \textcolor{keywordflow}{return} \textcolor{keyword}{true};
552 
553  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!F@{F}}
\index{F@{F}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{F(const Ipopt\+::\+Number $\ast$x, std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&points\+\_\+on, bool new\+\_\+x)}{F(const Ipopt::Number *x, std::deque< yarp::sig::Vector > &points_on, bool new_x)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::F (
\begin{DoxyParamCaption}
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&}]{points\+\_\+on, }
\item[{bool}]{new\+\_\+x}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a1ed524c1fd216594e82a6b066c59ff9c}


Auxiliary function for computing cost function of the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em x} & is the variable \\
\hline
{\em points\+\_\+on} & is object point cloud \\
\hline
{\em new\+\_\+x} & takes into account is the variable has been updated or not  the cost function value \\
\hline
\end{DoxyParams}


Definition at line 237 of file superquadric.\+cpp.


\begin{DoxyCode}
238  \{
239      \textcolor{keywordtype}{double} value=0.0;
240 
241      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0;i<points\_on.size();i++)
242          value+= pow( pow(f(\textcolor{keywordtype}{object},x,points\_on[i]),\textcolor{keywordtype}{object}[3])-1,2 );
243 
244      euler[0]=x[3];
245      euler[1]=x[4];
246      euler[2]=x[5];
247      H\_x=euler2dcm(euler);
248      euler[0]=x[0];
249      euler[1]=x[1];
250      euler[2]=x[2];
251      H\_x.setSubcol(euler,0,3);
252 
253      Matrix H(4,4);
254      H=H\_x*H\_h2w;
255 
256      Vector xv(3,0.0);
257      xv[0]=H(0,3);
258      xv[1]=H(1,3);
259      xv[2]=H(2,3);
260      value*=\textcolor{keywordtype}{object}[0]*\textcolor{keywordtype}{object}[1]*\textcolor{keywordtype}{object}[2]/points\_on.size();
261 
262      aux\_objvalue=value;
263  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!f@{f}}
\index{f@{f}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{f(yarp\+::sig\+::\+Vector \&obj, const Ipopt\+::\+Number $\ast$x, yarp\+::sig\+::\+Vector \&point)}{f(yarp::sig::Vector &obj, const Ipopt::Number *x, yarp::sig::Vector &point)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::f (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{obj, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{yarp\+::sig\+::\+Vector \&}]{point}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a88efaceff4a2274a91e13dcc95ad46d1}


Auxiliary function for computing cost function of the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em obj} & is the Vector of the object \\
\hline
{\em x} & is the variable \\
\hline
{\em point} & is one point of the point cloud \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a part of the cost function value 
\end{DoxyReturn}


Definition at line 266 of file superquadric.\+cpp.


\begin{DoxyCode}
267  \{
268      Matrix H(4,4);
269 
270      Vector point\_tr(4,0.0);
271      Vector point\_tmp(4,1.0);
272      point\_tmp.setSubvector(0,point);
273 
274      euler[0]=x[3];
275      euler[1]=x[4];
276      euler[2]=x[5];
277      H\_x=euler2dcm(euler);
278      euler[0]=x[0];
279      euler[1]=x[1];
280      euler[2]=x[2];
281      H\_x.setSubcol(euler,0,3);
282 
283      point\_tr=H\_x*point\_tmp;
284 
285      \textcolor{keywordtype}{double} num1=H\_o2w(0,0)*point\_tr[0]+H\_o2w(0,1)*point\_tr[1]+H\_o2w(0,2)*point\_tr[2]-obj[5]*H\_o2w(0,0)-obj
      [6]*H\_o2w(0,1)-obj[7]*H\_o2w(0,2);
286      \textcolor{keywordtype}{double} num2=H\_o2w(1,0)*point\_tr[0]+H\_o2w(1,1)*point\_tr[1]+H\_o2w(1,2)*point\_tr[2]-obj[5]*H\_o2w(1,0)-obj
      [6]*H\_o2w(1,1)-obj[7]*H\_o2w(1,2);
287      \textcolor{keywordtype}{double} num3=H\_o2w(2,0)*point\_tr[0]+H\_o2w(2,1)*point\_tr[1]+H\_o2w(2,2)*point\_tr[2]-obj[5]*H\_o2w(2,0)-obj
      [6]*H\_o2w(2,1)-obj[7]*H\_o2w(2,2);
288 
289      \textcolor{keywordtype}{double} tmp=pow(abs(num1/obj[0]),2.0/obj[4]) + pow(abs(num2/obj[1]),2.0/obj[4]);
290 
291      \textcolor{keywordflow}{return} pow( abs(tmp),obj[4]/obj[3]) + pow( abs(num3/obj[2]),(2.0/obj[3]));
292  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!F\+\_\+v@{F\+\_\+v}}
\index{F\+\_\+v@{F\+\_\+v}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{F\+\_\+v(yarp\+::sig\+::\+Vector \&x, std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&points\+\_\+on)}{F_v(yarp::sig::Vector &x, std::deque< yarp::sig::Vector > &points_on)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::\+F\+\_\+v (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{x, }
\item[{std\+::deque$<$ yarp\+::sig\+::\+Vector $>$ \&}]{points\+\_\+on}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_aa9ba169c71508e72c011cc43e94b1fed}


Auxiliary function for computing the gradient of cost function of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em x} & is the variable \\
\hline
{\em points\+\_\+on} & is one point of object point cloud \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cost function value 
\end{DoxyReturn}


Definition at line 295 of file superquadric.\+cpp.


\begin{DoxyCode}
296  \{
297      \textcolor{keywordtype}{double} value=0.0;
298 
299      \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0;i<points\_on.size();i++)
300         value+= pow( pow(f_v(\textcolor{keywordtype}{object},x,points\_on[i]),\textcolor{keywordtype}{object}[3])-1,2 );
301 
302      value*=\textcolor{keywordtype}{object}[0]*\textcolor{keywordtype}{object}[1]*\textcolor{keywordtype}{object}[2]/points\_on.size();
303 
304      euler[0]=x[3];
305      euler[1]=x[4];
306      euler[2]=x[5];
307      H\_x=euler2dcm(euler);
308      euler[0]=x[0];
309      euler[1]=x[1];
310      euler[2]=x[2];
311      H\_x.setSubcol(euler,0,3);
312 
313      Matrix H(4,4);
314      H=H\_x*H\_h2w;
315 
316      \textcolor{keywordflow}{return} value;
317  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!f\+\_\+v@{f\+\_\+v}}
\index{f\+\_\+v@{f\+\_\+v}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{f\+\_\+v(yarp\+::sig\+::\+Vector \&obj, yarp\+::sig\+::\+Vector \&x, yarp\+::sig\+::\+Vector \&point)}{f_v(yarp::sig::Vector &obj, yarp::sig::Vector &x, yarp::sig::Vector &point)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::f\+\_\+v (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{obj, }
\item[{yarp\+::sig\+::\+Vector \&}]{x, }
\item[{yarp\+::sig\+::\+Vector \&}]{point}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_ab67b259991b21ef9c7d1a81a3cb31228}


Auxiliary function for computing the gradient cost function of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em obj} & is the Vector of the object \\
\hline
{\em x} & is the variable \\
\hline
{\em point} & is one point of the point cloud \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a part of the cost function value 
\end{DoxyReturn}


Definition at line 320 of file superquadric.\+cpp.


\begin{DoxyCode}
321  \{
322      Vector point\_tr(4,0.0);
323      Vector point\_tmp(4,1.0);
324      point\_tmp.setSubvector(0,point);
325      euler[0]=x[3];
326      euler[1]=x[4];
327      euler[2]=x[5];
328      H\_x=euler2dcm(euler);
329      euler[0]=x[0];
330      euler[1]=x[1];
331      euler[2]=x[2];
332      H\_x.setSubcol(euler,0,3);
333      Matrix H;
334      H.resize(4,4);
335 
336      point\_tr=H\_x*point\_tmp;
337 
338      \textcolor{keywordtype}{double} num1=H\_o2w(0,0)*point\_tr[0]+H\_o2w(0,1)*point\_tr[1]+H\_o2w(0,2)*point\_tr[2]-obj[5]*H\_o2w(0,0)-obj
      [6]*H\_o2w(0,1)-obj[7]*H\_o2w(0,2);
339      \textcolor{keywordtype}{double} num2=H\_o2w(1,0)*point\_tr[0]+H\_o2w(1,1)*point\_tr[1]+H\_o2w(1,2)*point\_tr[2]-obj[5]*H\_o2w(1,0)-obj
      [6]*H\_o2w(1,1)-obj[7]*H\_o2w(1,2);
340      \textcolor{keywordtype}{double} num3=H\_o2w(2,0)*point\_tr[0]+H\_o2w(2,1)*point\_tr[1]+H\_o2w(2,2)*point\_tr[2]-obj[5]*H\_o2w(2,0)-obj
      [6]*H\_o2w(2,1)-obj[7]*H\_o2w(2,2);
341 
342      \textcolor{keywordtype}{double} tmp=pow(abs(num1/obj[0]),2.0/obj[4]) + pow(abs(num2/obj[1]),2.0/obj[4]);
343 
344      \textcolor{keywordflow}{return} pow( abs(tmp),obj[4]/obj[3]) + pow( abs(num3/obj[2]),(2.0/obj[3]));
345  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!f\+\_\+v2@{f\+\_\+v2}}
\index{f\+\_\+v2@{f\+\_\+v2}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{f\+\_\+v2(yarp\+::sig\+::\+Vector \&obj, yarp\+::sig\+::\+Vector \&x, yarp\+::sig\+::\+Vector \&point\+\_\+tr)}{f_v2(yarp::sig::Vector &obj, yarp::sig::Vector &x, yarp::sig::Vector &point_tr)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::f\+\_\+v2 (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{obj, }
\item[{yarp\+::sig\+::\+Vector \&}]{x, }
\item[{yarp\+::sig\+::\+Vector \&}]{point\+\_\+tr}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a2cc9996f039f3049666a39bbf0e5a5f5}


Auxiliary function for computing the gradient cost function of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em obj} & is the Vector of the object \\
\hline
{\em x} & is the variable \\
\hline
{\em point\+\_\+tr} & is one point of the point cloud \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a part of the cost function value 
\end{DoxyReturn}


Definition at line 348 of file superquadric.\+cpp.


\begin{DoxyCode}
349  \{
350      \textcolor{keywordtype}{double} num1=H\_o2w(0,0)*point\_tr[0]+H\_o2w(0,1)*point\_tr[1]+H\_o2w(0,2)*point\_tr[2]-obj[5]*H\_o2w(0,0)-obj
      [6]*H\_o2w(0,1)-obj[7]*H\_o2w(0,2);
351      \textcolor{keywordtype}{double} num2=H\_o2w(1,0)*point\_tr[0]+H\_o2w(1,1)*point\_tr[1]+H\_o2w(1,2)*point\_tr[2]-obj[5]*H\_o2w(1,0)-obj
      [6]*H\_o2w(1,1)-obj[7]*H\_o2w(1,2);
352      \textcolor{keywordtype}{double} num3=H\_o2w(2,0)*point\_tr[0]+H\_o2w(2,1)*point\_tr[1]+H\_o2w(2,2)*point\_tr[2]-obj[5]*H\_o2w(2,0)-obj
      [6]*H\_o2w(2,1)-obj[7]*H\_o2w(2,2);
353 
354      \textcolor{keywordtype}{double} tmp=pow(abs(num1/obj[0]),2.0/obj[4]) + pow(abs(num2/obj[1]),2.0/obj[4]);
355 
356      \textcolor{keywordflow}{return} pow( abs(tmp),obj[4]/obj[3]) + pow( abs(num3/obj[2]),(2.0/obj[3]));
357  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!finalize\+\_\+solution@{finalize\+\_\+solution}}
\index{finalize\+\_\+solution@{finalize\+\_\+solution}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{finalize\+\_\+solution(\+Ipopt\+::\+Solver\+Return status, Ipopt\+::\+Index n, const Ipopt\+::\+Number $\ast$x, const Ipopt\+::\+Number $\ast$z\+\_\+\+L, const Ipopt\+::\+Number $\ast$z\+\_\+\+U, Ipopt\+::\+Index m, const Ipopt\+::\+Number $\ast$g, const Ipopt\+::\+Number $\ast$lambda, Ipopt\+::\+Number obj\+\_\+value, const Ipopt\+::\+Ipopt\+Data $\ast$ip\+\_\+data, Ipopt\+::\+Ipopt\+Calculated\+Quantities $\ast$ip\+\_\+cq)}{finalize_solution(Ipopt::SolverReturn status, Ipopt::Index n, const Ipopt::Number *x, const Ipopt::Number *z_L, const Ipopt::Number *z_U, Ipopt::Index m, const Ipopt::Number *g, const Ipopt::Number *lambda, Ipopt::Number obj_value, const Ipopt::IpoptData *ip_data, Ipopt::IpoptCalculatedQuantities *ip_cq)}}]{\setlength{\rightskip}{0pt plus 5cm}void grasping\+\_\+\+N\+L\+P\+::finalize\+\_\+solution (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Solver\+Return}]{status, }
\item[{Ipopt\+::\+Index}]{n, }
\item[{const Ipopt\+::\+Number $\ast$}]{x, }
\item[{const Ipopt\+::\+Number $\ast$}]{z\+\_\+L, }
\item[{const Ipopt\+::\+Number $\ast$}]{z\+\_\+U, }
\item[{Ipopt\+::\+Index}]{m, }
\item[{const Ipopt\+::\+Number $\ast$}]{g, }
\item[{const Ipopt\+::\+Number $\ast$}]{lambda, }
\item[{Ipopt\+::\+Number}]{obj\+\_\+value, }
\item[{const Ipopt\+::\+Ipopt\+Data $\ast$}]{ip\+\_\+data, }
\item[{Ipopt\+::\+Ipopt\+Calculated\+Quantities $\ast$}]{ip\+\_\+cq}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a99ab31792445766535d8117299b57da8}


Finalize the solution. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em x} & is the variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em init\+\_\+z} & is an ipopt variable \\
\hline
{\em z\+\_\+L} & is an ipopt variable \\
\hline
{\em z\+\_\+U} & is an ipopt variable \\
\hline
{\em status} & says if the problem has been solved or not \\
\hline
{\em obj\+\_\+value} & is the final cost function values \\
\hline
\end{DoxyParams}


Definition at line 636 of file superquadric.\+cpp.


\begin{DoxyCode}
642 \{
643    solution.resize(n);
644 
645    euler[0]=x[3];
646    euler[1]=x[4];
647    euler[2]=x[5];
648    H\_x=euler2dcm(euler);
649    euler[0]=x[0];
650    euler[1]=x[1];
651    euler[2]=x[2];
652    H\_x.setSubcol(euler,0,3);
653 
654    Matrix H;
655    H.resize(4,4);
656    H=H\_x*H\_h2w;
657 
658    solution.setSubvector(3,dcm2euler(H.transposed()));
659 
660    \textcolor{keywordflow}{for} (Ipopt::Index i=0; i<3; i++)
661        solution[i]=H(i,3);
662 
663     robot_pose.resize(6,0.0);
664     robot_pose.setSubvector(3,dcm2euler(H));
665 
666     \textcolor{keywordflow}{if} (l_o_r==\textcolor{stringliteral}{"right"})
667     \{
668         robot_pose.setSubvector(0,solution.subVector(0,2)-(hand[0]+displacement[2])*(H.getCol(2).subVector(
      0,2)));
669         robot_pose.setSubvector(0,robot_pose.subVector(0,2)-displacement[0]*(H.getCol(0).subVector(0,2)));
670         robot_pose.setSubvector(0,robot_pose.subVector(0,2)-displacement[1]*(H.getCol(1).subVector(0,2)));
671     \}
672     \textcolor{keywordflow}{else}
673     \{
674         robot_pose.setSubvector(0,solution.subVector(0,2)+(hand[0]+displacement[2])*(H.getCol(2).subVector(
      0,2)));
675         robot_pose.setSubvector(0,robot_pose.subVector(0,2)-displacement[0]*(H.getCol(0).subVector(0,2)));
676         robot_pose.setSubvector(0,robot_pose.subVector(0,2)-displacement[1]*(H.getCol(1).subVector(0,2)));
677     \}
678 
679     tmp\_value=0.0;
680 
681     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0;i<points\_on.size();i++)
682     \{
683         Vector point(3,0.0);
684         point=points\_on[i];
685 
686         Vector point\_tr(4,0.0);
687         Vector point\_tmp(4,1.0);
688         point\_tmp.setSubvector(0,point);
689 
690         euler[0]=x[3];
691         euler[1]=x[4];
692         euler[2]=x[5];
693         H\_x=euler2dcm(euler);
694         euler[0]=x[0];
695         euler[1]=x[1];
696         euler[2]=x[2];
697         H\_x.setSubcol(euler,0,3);
698 
699         point\_tr=H\_x*point\_tmp;
700 
701         tmp\_value+= pow( pow(f(\textcolor{keywordtype}{object},x,points\_on[i]),\textcolor{keywordtype}{object}[3])-1,2 );
702     \}
703 
704     tmp\_value/=points\_on.size();
705 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!G\+\_\+v@{G\+\_\+v}}
\index{G\+\_\+v@{G\+\_\+v}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{G\+\_\+v(yarp\+::sig\+::\+Vector \&x, int i)}{G_v(yarp::sig::Vector &x, int i)}}]{\setlength{\rightskip}{0pt plus 5cm}double grasping\+\_\+\+N\+L\+P\+::\+G\+\_\+v (
\begin{DoxyParamCaption}
\item[{yarp\+::sig\+::\+Vector \&}]{x, }
\item[{int}]{i}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_acc0ace418469386b16adb2c70a98c14d}


Auxiliary function for computing the constraints of the nonlinear problem. 


\begin{DoxyParams}{Parameters}
{\em x} & is the variable \\
\hline
{\em i} & is the number of the constraints \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the constraints value 
\end{DoxyReturn}


Definition at line 445 of file superquadric.\+cpp.


\begin{DoxyCode}
446  \{
447      Vector g(3,0.0);
448 
449      Matrix H\_x,H;
450      H\_x.resize(4,4);
451      H.resize(4,4);
452      euler[0]=x[3];
453      euler[1]=x[4];
454      euler[2]=x[5];
455      H\_x=euler2dcm(euler);
456      euler[0]=x[0];
457      euler[1]=x[1];
458      euler[2]=x[2];
459      H\_x.setSubcol(euler,0,3);
460 
461      H=H\_x*H\_h2w;
462 
463      g[0]=H(2,2);
464      g[1]=H(0,0);
465      g[2]=H(1,2);
466      g[4]=H(1,0);
467 
468      Vector x\_min;
469      \textcolor{keywordtype}{double} minz=10.0;
470 
471      \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i1=0; i1<points\_on.size(); i1++)
472      \{
473          Vector pnt(4,1.0);
474          pnt.setSubvector(0,points\_on[i1]);
475          Vector point=H\_x*pnt;
476 
477          \textcolor{keywordflow}{if} (point[2]<minz)
478          \{
479              minz=point[2];
480              x\_min=point;
481          \}
482      \}
483 
484      g[3]=plane(0,0)*x\_min[0]+plane(1,0)*x\_min[1]+plane(2,0)*x\_min[2]+plane(3,0);
485 
486      Vector robotPose(3,0.0);
487      Vector x\_tmp(3,0.0);
488      x\_tmp[0]=x[0];
489      x\_tmp[1]=x[1];
490      x\_tmp[2]=x[2];
491 
492      \textcolor{keywordflow}{if} (l_o_r==\textcolor{stringliteral}{"right"})
493         robotPose=x\_tmp-hand[0]*(H.getCol(2).subVector(0,2));
494      \textcolor{keywordflow}{else}
495          robotPose=x\_tmp+hand[0]*(H.getCol(2).subVector(0,2));
496 
497      g[5]=\textcolor{keywordtype}{object}[0]*\textcolor{keywordtype}{object}[1]*\textcolor{keywordtype}{object}[2]*(pow(f_v2(\textcolor{keywordtype}{object},x\_tmp, robotPose), \textcolor{keywordtype}{object}[3]) -1);
498 
499      \textcolor{keywordflow}{return} g[i];
500  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!get\+\_\+bounds\+\_\+info@{get\+\_\+bounds\+\_\+info}}
\index{get\+\_\+bounds\+\_\+info@{get\+\_\+bounds\+\_\+info}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{get\+\_\+bounds\+\_\+info(\+Ipopt\+::\+Index n, Ipopt\+::\+Number $\ast$x\+\_\+l, Ipopt\+::\+Number $\ast$x\+\_\+u, Ipopt\+::\+Index m, Ipopt\+::\+Number $\ast$g\+\_\+l, Ipopt\+::\+Number $\ast$g\+\_\+u)}{get_bounds_info(Ipopt::Index n, Ipopt::Number *x_l, Ipopt::Number *x_u, Ipopt::Index m, Ipopt::Number *g_l, Ipopt::Number *g_u)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::get\+\_\+bounds\+\_\+info (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{Ipopt\+::\+Number $\ast$}]{x\+\_\+l, }
\item[{Ipopt\+::\+Number $\ast$}]{x\+\_\+u, }
\item[{Ipopt\+::\+Index}]{m, }
\item[{Ipopt\+::\+Number $\ast$}]{g\+\_\+l, }
\item[{Ipopt\+::\+Number $\ast$}]{g\+\_\+u}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a1be828e10f1182f3befccbafdb90b577}


Get variable bounds for the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em x\+\_\+l} & is the lower bound of the variable \\
\hline
{\em x\+\_\+u} & is the upper bound of the variable \\
\hline
{\em g\+\_\+l} & is the lower bound of the constraints \\
\hline
{\em g\+\_\+u} & is the upper bound of the constraints \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 
\end{DoxyReturn}


Definition at line 195 of file superquadric.\+cpp.


\begin{DoxyCode}
197 \{
198     \textcolor{keywordflow}{for} (Ipopt::Index i=0; i<n; i++)
199     \{
200        x\_l[i]=bounds(i,0);
201        x\_u[i]=bounds(i,1);
202     \}
203 
204     \textcolor{keywordflow}{for} (Ipopt::Index i=0; i<m; i++)
205     \{
206        g\_l[i]=bounds\_constr(i,0);
207        g\_u[i]=bounds\_constr(i,1);
208     \}
209 
210     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
211 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!get\+\_\+hand@{get\+\_\+hand}}
\index{get\+\_\+hand@{get\+\_\+hand}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{get\+\_\+hand() const }{get_hand() const }}]{\setlength{\rightskip}{0pt plus 5cm}Vector grasping\+\_\+\+N\+L\+P\+::get\+\_\+hand (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classgrasping__NLP_a1c012d56ae1dc44263eac74861b59008}


Get the hand ellipsoid pose. 

\begin{DoxyReturn}{Returns}
the hand ellipsoid in the final pose 
\end{DoxyReturn}


Definition at line 714 of file superquadric.\+cpp.


\begin{DoxyCode}
715 \{
716    \textcolor{keywordflow}{return} hand;
717 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!get\+\_\+nlp\+\_\+info@{get\+\_\+nlp\+\_\+info}}
\index{get\+\_\+nlp\+\_\+info@{get\+\_\+nlp\+\_\+info}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{get\+\_\+nlp\+\_\+info(\+Ipopt\+::\+Index \&n, Ipopt\+::\+Index \&m, Ipopt\+::\+Index \&nnz\+\_\+jac\+\_\+g, Ipopt\+::\+Index \&nnz\+\_\+h\+\_\+lag, Ipopt\+::\+T\+N\+L\+P\+::\+Index\+Style\+Enum \&index\+\_\+style)}{get_nlp_info(Ipopt::Index &n, Ipopt::Index &m, Ipopt::Index &nnz_jac_g, Ipopt::Index &nnz_h_lag, Ipopt::TNLP::IndexStyleEnum &index_style)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::get\+\_\+nlp\+\_\+info (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index \&}]{n, }
\item[{Ipopt\+::\+Index \&}]{m, }
\item[{Ipopt\+::\+Index \&}]{nnz\+\_\+jac\+\_\+g, }
\item[{Ipopt\+::\+Index \&}]{nnz\+\_\+h\+\_\+lag, }
\item[{Ipopt\+::\+T\+N\+L\+P\+::\+Index\+Style\+Enum \&}]{index\+\_\+style}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a49d0b788d4d17f32efca951ed6556ca0}


Get info for the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em nnz\+\_\+jac\+\_\+g} & is the dimensions of the jacobian \\
\hline
{\em nnz\+\_\+h\+\_\+lag} & is an ipopt variable \\
\hline
{\em index\+\_\+styl} & is an ipopt variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 
\end{DoxyReturn}


Definition at line 179 of file superquadric.\+cpp.


\begin{DoxyCode}
181 \{
182     n=6;
183     m=6;
184     nnz\_jac\_g=36;
185     nnz\_h\_lag=0;
186     index\_style=TNLP::C\_STYLE;
187     x\_v.resize(n,0.0);
188     bounds.resize(n,2);
189     bounds\_constr(m,2);
190 
191     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
192 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!get\+\_\+result@{get\+\_\+result}}
\index{get\+\_\+result@{get\+\_\+result}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{get\+\_\+result() const }{get_result() const }}]{\setlength{\rightskip}{0pt plus 5cm}Vector grasping\+\_\+\+N\+L\+P\+::get\+\_\+result (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classgrasping__NLP_a15ce27b41ee64c471a66ea3f9db49381}


Extract the solution. 

\begin{DoxyReturn}{Returns}
the superquadric as a Vector 
\end{DoxyReturn}


Definition at line 708 of file superquadric.\+cpp.


\begin{DoxyCode}
709 \{
710    \textcolor{keywordflow}{return} solution;
711 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!get\+\_\+starting\+\_\+point@{get\+\_\+starting\+\_\+point}}
\index{get\+\_\+starting\+\_\+point@{get\+\_\+starting\+\_\+point}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{get\+\_\+starting\+\_\+point(\+Ipopt\+::\+Index n, bool init\+\_\+x, Ipopt\+::\+Number $\ast$x, bool init\+\_\+z, Ipopt\+::\+Number $\ast$z\+\_\+\+L, Ipopt\+::\+Number $\ast$z\+\_\+\+U, Ipopt\+::\+Index m, bool init\+\_\+lambda, Ipopt\+::\+Number $\ast$lambda)}{get_starting_point(Ipopt::Index n, bool init_x, Ipopt::Number *x, bool init_z, Ipopt::Number *z_L, Ipopt::Number *z_U, Ipopt::Index m, bool init_lambda, Ipopt::Number *lambda)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::get\+\_\+starting\+\_\+point (
\begin{DoxyParamCaption}
\item[{Ipopt\+::\+Index}]{n, }
\item[{bool}]{init\+\_\+x, }
\item[{Ipopt\+::\+Number $\ast$}]{x, }
\item[{bool}]{init\+\_\+z, }
\item[{Ipopt\+::\+Number $\ast$}]{z\+\_\+L, }
\item[{Ipopt\+::\+Number $\ast$}]{z\+\_\+U, }
\item[{Ipopt\+::\+Index}]{m, }
\item[{bool}]{init\+\_\+lambda, }
\item[{Ipopt\+::\+Number $\ast$}]{lambda}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_aad767e5f7e77a811e11817ff1d3d179e}


Get the starting point for the nonlinear problem to be solved with ipopt. 


\begin{DoxyParams}{Parameters}
{\em n} & is the dimension of the variable \\
\hline
{\em init\+\_\+x} & is the starting point of the optimization problem \\
\hline
{\em x} & is the variable \\
\hline
{\em init\+\_\+z} & is an ipopt variable \\
\hline
{\em z\+\_\+L} & is an ipopt variable \\
\hline
{\em z\+\_\+U} & is an ipopt variable \\
\hline
{\em m} & is the number of constraints \\
\hline
{\em init\+\_\+lambda} & is an ipopt variable \\
\hline
{\em lambda} & is an ipopt variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true 
\end{DoxyReturn}


Definition at line 214 of file superquadric.\+cpp.


\begin{DoxyCode}
217  \{
218      \textcolor{keywordflow}{for}(Ipopt::Index i=0;i<n;i++)
219      \{
220          x[i]=hand[i+5];
221      \}
222 
223      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
224  \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!init@{init}}
\index{init@{init}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{init(const yarp\+::sig\+::\+Vector \&objectext, yarp\+::sig\+::\+Vector \&handext, int \&n\+\_\+handpoints, const std\+::string \&str\+\_\+hand)}{init(const yarp::sig::Vector &objectext, yarp::sig::Vector &handext, int &n_handpoints, const std::string &str_hand)}}]{\setlength{\rightskip}{0pt plus 5cm}void grasping\+\_\+\+N\+L\+P\+::init (
\begin{DoxyParamCaption}
\item[{const yarp\+::sig\+::\+Vector \&}]{objectext, }
\item[{yarp\+::sig\+::\+Vector \&}]{handext, }
\item[{int \&}]{n\+\_\+handpoints, }
\item[{const std\+::string \&}]{str\+\_\+hand}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_abcf09fd329994523df9cebab0c607006}


Initialization function. 


\begin{DoxyParams}{Parameters}
{\em objectext} & is the object superquadric \\
\hline
{\em handext} & is the hand ellipsoid \\
\hline
{\em n\+\_\+handpoints} & is the number of points to sample on the hand ellipsoid \\
\hline
{\em str\+\_\+hand} & is the name of the hand \\
\hline
\end{DoxyParams}


Definition at line 45 of file superquadric.\+cpp.



Referenced by Grasp\+Computation\+::compute\+Pose().


\begin{DoxyCode}
46 \{
47     hand=handext;
48     \textcolor{keywordtype}{object}=objectext;
49 
50     H\_o2w.resize(4,4);
51     H\_h2w.resize(4,4);
52     H\_x.resize(4,4);
53     euler.resize(3,0.0);
54 
55     euler[0]=\textcolor{keywordtype}{object}[8];
56     euler[1]=\textcolor{keywordtype}{object}[9];
57     euler[2]=\textcolor{keywordtype}{object}[10];
58     H\_o2w=euler2dcm(euler);
59     euler[0]=\textcolor{keywordtype}{object}[5];
60     euler[1]=\textcolor{keywordtype}{object}[6];
61     euler[2]=\textcolor{keywordtype}{object}[7];
62     H\_o2w.setSubcol(euler,0,3);
63 
64     euler[0]=hand[8];
65     euler[1]=hand[9];
66     euler[2]=hand[10];
67     H\_h2w=euler2dcm(euler);
68     euler[0]=hand[5];
69     euler[1]=hand[6];
70     euler[2]=hand[7];
71     H\_h2w.setSubcol(euler,0,3);
72 
73     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i=0; i<(int)sqrt(n\_handpoints); i++)
74     \{
75         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{double} theta=-M\_PI/2; theta<=0; theta+=M\_PI/((int)sqrt(n\_handpoints)))
76         \{
77             points\_on.push\_back(computePointsHand(hand,i, (\textcolor{keywordtype}{int})sqrt(n\_handpoints), str\_hand, theta));
78         \}
79     \}
80 
81     aux\_objvalue=0.0;
82 \}
\end{DoxyCode}
\index{grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}!read\+Matrix@{read\+Matrix}}
\index{read\+Matrix@{read\+Matrix}!grasping\+\_\+\+N\+LP@{grasping\+\_\+\+N\+LP}}
\subsubsection[{\texorpdfstring{read\+Matrix(const std\+::string \&tag, yarp\+::sig\+::\+Matrix \&matrix, const int \&dimension, yarp\+::os\+::\+Resource\+Finder $\ast$rf)}{readMatrix(const std::string &tag, yarp::sig::Matrix &matrix, const int &dimension, yarp::os::ResourceFinder *rf)}}]{\setlength{\rightskip}{0pt plus 5cm}bool grasping\+\_\+\+N\+L\+P\+::read\+Matrix (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{tag, }
\item[{yarp\+::sig\+::\+Matrix \&}]{matrix, }
\item[{const int \&}]{dimension, }
\item[{yarp\+::os\+::\+Resource\+Finder $\ast$}]{rf}
\end{DoxyParamCaption}
)}\label{classgrasping__NLP_a8104499f39d0f3705760a50745510c14}


Function for reading matrices from config files. 


\begin{DoxyParams}{Parameters}
{\em tag} & is the name of the quantity to be read from text \\
\hline
{\em matrix} & is the matrix to be filled \\
\hline
{\em dimensions} & is the matrix dimensions \\
\hline
{\em rf} & is the resource finder \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true/false on success/failure 
\end{DoxyReturn}


Definition at line 577 of file superquadric.\+cpp.


\begin{DoxyCode}
578 \{
579    \textcolor{keywordtype}{string} tag\_x=tag+\textcolor{stringliteral}{"\_x"};
580    \textcolor{keywordtype}{string} tag\_y=tag+\textcolor{stringliteral}{"\_y"};
581    \textcolor{keywordtype}{bool} check\_x;
582 
583    \textcolor{keywordflow}{if}(tag==\textcolor{stringliteral}{"x0"} || tag==\textcolor{stringliteral}{"plane"})
584    \{
585        \textcolor{keywordflow}{if} (Bottle *b=rf->find(tag.c\_str()).asList())
586        \{
587            Vector col;
588            \textcolor{keywordflow}{if} (b->size()>=dimension)
589            \{
590                \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<b->size();i++)
591                    col.push\_back(b->get(i).asDouble());
592 
593                matrix.setCol(0, col);
594            \}
595            \textcolor{keywordflow}{return} \textcolor{keyword}{true};
596        \}
597    \}
598    \textcolor{keywordflow}{else}
599    \{
600        \textcolor{keywordflow}{if}(tag==\textcolor{stringliteral}{"bounds\_right"} || tag==\textcolor{stringliteral}{"bounds\_constr\_right"} || tag==\textcolor{stringliteral}{"bounds\_left"} || tag==\textcolor{stringliteral}{"
      bounds\_constr\_left"})
601        \{
602            tag\_x=tag+\textcolor{stringliteral}{"\_l"};
603            tag\_y=tag+\textcolor{stringliteral}{"\_u"};
604        \}
605 
606        \textcolor{keywordflow}{if} (Bottle *b=rf->find(tag\_x.c\_str()).asList())
607        \{
608            Vector col;
609            \textcolor{keywordflow}{if} (b->size()>=dimension)
610            \{
611                \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<b->size();i++)
612                    col.push\_back(b->get(i).asDouble());
613 
614                matrix.setCol(0, col);
615            \}
616            check\_x=\textcolor{keyword}{true};
617 
618        \}
619        \textcolor{keywordflow}{if} (Bottle *b=rf->find(tag\_y.c\_str()).asList())
620        \{
621            Vector col;
622            \textcolor{keywordflow}{if} (b->size()>=dimension)
623            \{
624                \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<b->size();i++)
625                    col.push\_back(b->get(i).asDouble());
626                matrix.setCol(1, col);
627            \}
628            \textcolor{keywordflow}{if}(check\_x==\textcolor{keyword}{true})
629                \textcolor{keywordflow}{return} \textcolor{keyword}{true};
630        \}
631    \}
632 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
633 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/gvezzani/\+Desktop/\+Ph\+D/\+Anno\+\_\+1/super\+Quadratiche/superquadric-\/grasping/include/superquadric.\+h\item 
/home/gvezzani/\+Desktop/\+Ph\+D/\+Anno\+\_\+1/super\+Quadratiche/superquadric-\/grasping/src/superquadric.\+cpp\end{DoxyCompactItemize}
